# frozen_string_literal: true
require 'json'
require 'set'
require 'digest'
require 'securerandom'

class SlotGame
  attr_reader :reels, :paytable, :rows, :cols, :server_seed, :server_seed_hash

  def initialize(config_path = 'config.json', server_seed = nil)
    begin
      config_content = File.read(config_path)
      config = JSON.parse(config_content)
    rescue StandardError => e
      puts "Error loading config from #{config_path}: #{e.message}. Using default empty config."
      config = { 'reels' => [], 'paytable' => {} }
    end
    
    @reels     = config['reels'] || []
    @paytable  = config['paytable'] || {}
    @cols      = @reels.is_a?(Array) ? @reels.length : 0
    @rows      = 3 # Fixed as per existing logic
    @server_seed = server_seed || SecureRandom.hex(16)
    # Ensure server_seed is a string before hashing, as SecureRandom.hex returns a string.
    @server_seed_hash = Digest::SHA256.hexdigest(@server_seed.to_s)
  end

  # Standard spin using the game's current server_seed.
  # Not provably fair with client_seed/nonce, but deterministic for a given server_seed.
  def spin
    screen_columns = []
    (@reels || []).each_with_index do |reel_symbols, col_idx|
      if reel_symbols.nil? || reel_symbols.empty? || @rows <= 0
        screen_columns << Array.new(@rows || 3) # Default column
        next
      end
      # Seed per column based on the instance's server_seed
      seed_for_reel_stop = "#{@server_seed}:reel_stop:#{col_idx}"
      hash = Digest::SHA256.hexdigest(seed_for_reel_stop)
      stop_index = hash.to_i(16) % reel_symbols.length

      column = Array.new(@rows) do |row_idx|
        reel_symbols[(stop_index + row_idx) % reel_symbols.length]
      end
      screen_columns << column
    end
    screen_columns # Returns array of columns
  end

  # Provably fair spin: deterministic based on server_seed, client_seed, and nonce.
  def provably_fair_spin(server_seed, client_seed, nonce)
    screen_columns = []
    (@reels || []).each_with_index do |reel_symbols, col_idx|
      if reel_symbols.nil? || reel_symbols.empty? || @rows <= 0
        screen_columns << Array.new(@rows || 3) # Default column
        next
      end
      
      # Combine all inputs for a unique hash per reel position
      seed_for_reel_stop = "#{server_seed}:#{client_seed}:#{nonce}:reel_stop:#{col_idx}"
      hash = Digest::SHA256.hexdigest(seed_for_reel_stop)
      stop_index = hash.to_i(16) % reel_symbols.length

      column = Array.new(@rows) do |row_idx|
        reel_symbols[(stop_index + row_idx) % reel_symbols.length]
      end
      screen_columns << column
    end
    screen_columns # Returns array of columns
  end

  # Verifies a spin result by re-generating based on seeds/nonce and comparing to an expected_screen.
  def verify_spin(server_seed, client_seed, nonce, expected_screen)
    return false if expected_screen.nil? # Cannot verify against nothing
    generated_columns = provably_fair_spin(server_seed, client_seed, nonce)
    generated_columns == expected_screen
  end

  # Returns the screen as rows for visualization (transpose)
  def screen_rows(screen_columns)
    # Ensure screen_columns is not nil and is an array of arrays before transposing
    return [] if screen_columns.nil? || !screen_columns.is_a?(Array) || screen_columns.any? { |col| !col.is_a?(Array) }
    # Ensure all columns have the same size for transpose to work correctly, or handle gracefully.
    # For simplicity, assuming valid structure as generated by spin methods.
    screen_columns.transpose
  end

  # Parallel simple calculation of win using column counts
  def calculate_win(screen, bet_amount)
    total_win = 0.0
    # For each symbol, multiply column counts for every payout length
    paytable.each do |sym, payouts|
      # counts of (symbol or WILD) in each column
      counts = screen.map { |col| col.count(sym) + col.count('WILD') }
      payouts.each_with_index do |payout, idx|
        length = idx + 1
        # only lengths >=2, within column size, and positive payout
        next if length < 2 || length > counts.size || payout.to_i <= 0
        ways = counts.take(length).reduce(1, :*)
        total_win += ways * payout * bet_amount
      end
    end
    total_win
  end

  # Returns an array of paths (each path is an array of coordinates) for symbol sym and length
  # The path always starts from the first column and goes consecutively to the right
  def ways_paths_for_length(screen, sym, length)
    rows = screen.size
    cols = screen[0].size
    return [] if length > cols
    return [] unless length == 2 || length == 3 # only for 2 and 3 in a row
    start_positions = []
    rows.times do |row|
      start_positions << [[row, 0]] if screen[row][0] == sym || screen[row][0] == 'WILD'
    end
    paths = []
    queue = start_positions.dup
    until queue.empty?
      path = queue.shift
      col = path.last[1]
      if path.size == length
        paths << path
        next
      end
      next_col = col + 1
      next if next_col >= cols
      rows.times do |row|
        if screen[row][next_col] == sym || screen[row][next_col] == 'WILD'
          queue << (path + [[row, next_col]])
        end
      end
    end
    paths.map { |p| p.map(&:dup) }
  end

  # Returns the number of ways for symbol sym and length
  def ways_for_length(screen, sym, length)
    rows = screen.size
    cols = screen[0].size
    return 0 if length > cols
    # For each starting position in the first column
    start_positions = []
    rows.times do |row|
      start_positions << [row, 0] if screen[row][0] == sym || screen[row][0] == 'WILD'
    end
    count = 0
    queue = start_positions.map { |pos| [pos] }
    until queue.empty?
      path = queue.shift
      col = path.last[1]
      if path.size == length
        count += 1
        next
      end
      next_col = col + 1
      next if next_col >= cols
      rows.times do |row|
        if screen[row][next_col] == sym || screen[row][next_col] == 'WILD'
          queue << (path + [[row, next_col]])
        end
      end
    end
    count
  end

  # Returns an array of winning paths: [{symbol:, coords: [[row, col], ...]}]
  def winning_paths(screen)
    paths = []
    # Convert columns to row-major matrix
    matrix = screen.transpose
    paytable.each_key do |sym|
      ways, length, all_paths = ways_and_length_with_coords(matrix, sym)
      next if ways.zero? || length < 2
      payout = paytable[sym][length - 1] || 0
      next if payout <= 0
      all_paths.each do |coords|
        paths << {symbol: sym, coords: coords, length: length, payout: payout}
      end
    end
    paths
  end

  # Returns [ways, length, all_paths]:
  # - ways: number of ways
  # - length: length of the way
  # - all_paths: array of paths (each path is an array of coordinates [[row, col], ...])
  def ways_and_length_with_coords(screen, sym)
    rows = screen.size
    cols = screen[0].size
    # For each starting position in the first column
    start_positions = []
    rows.times do |row|
      start_positions << [row, 0] if screen[row][0] == sym || screen[row][0] == 'WILD'
    end
    all_paths = []
    max_length = 0
    # BFS for all possible paths
    queue = start_positions.map { |pos| [pos] }
    until queue.empty?
      path = queue.shift
      col = path.last[1]
      if col == cols - 1
        all_paths << path
        max_length = [max_length, path.size].max
        next
      end
      next_col = col + 1
      rows.times do |row|
        if screen[row][next_col] == sym || screen[row][next_col] == 'WILD'
          queue << (path + [[row, next_col]])
        end
      end
      # If no continuation is found, record the path
      if queue.none? { |p| p[0...col+1] == path }
        all_paths << path
        max_length = [max_length, path.size].max
      end
    end
    # Keep only the maximum length paths
    max_paths = all_paths.select { |p| p.size == max_length }
    [max_paths.size, max_length, max_paths]
  end
end
